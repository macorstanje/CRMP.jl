var documenterSearchIndex = {"docs":
[{"location":"reaction_times/#Conditional-process","page":"Reaction times","title":"Conditional process","text":"","category":"section"},{"location":"reaction_times/","page":"Reaction times","title":"Reaction times","text":"Function used in the simulation of guided processes","category":"page"},{"location":"reaction_times/","page":"Reaction times","title":"Reaction times","text":"CurrentModule = CRMP","category":"page"},{"location":"reaction_times/","page":"Reaction times","title":"Reaction times","text":"method\nconstant_rate\ndecreasing_rate\nincreasing_rate\nthinning\nGillespie\ngettime\nsetŒ¥","category":"page"},{"location":"reaction_times/#CRMP.method","page":"Reaction times","title":"CRMP.method","text":"method\n\nsupertype for simulation methods, might find another name for it later\n\n\n\n\n\n","category":"type"},{"location":"reaction_times/#CRMP.constant_rate","page":"Reaction times","title":"CRMP.constant_rate","text":"constant_rate <: method\n\nused when the rates of the reactions in the network are constant in time\n\n\n\n\n\n","category":"type"},{"location":"reaction_times/#CRMP.decreasing_rate","page":"Reaction times","title":"CRMP.decreasing_rate","text":"decreasing_rate <: method\n\nused when the rates of the reactions in the network are decreasing in time.  This method utilizes a Poisson thinning with the current state as upper bound\n\n\n\n\n\n","category":"type"},{"location":"reaction_times/#CRMP.increasing_rate","page":"Reaction times","title":"CRMP.increasing_rate","text":"increasing_rate <: method\n\nused when the rates of the reactions in the network are increasing in time This method utilizes a Poisson thinning with the time at t+Œ¥ as upper bound. \n\n\n\n\n\n","category":"type"},{"location":"reaction_times/#CRMP.thinning","page":"Reaction times","title":"CRMP.thinning","text":"thinning <: method\n\nCan be used when the rates of the reactions in the network are bounded.  Utilizes the bounds in lemma ... (lower bound on hÃÉ(t,x), upper bound on hÃÉ(t,x+‚Ñì.Œæ))\n\n\n\n\n\n","category":"type"},{"location":"reaction_times/#CRMP.Gillespie","page":"Reaction times","title":"CRMP.Gillespie","text":"Gillespie <: method\n\nGillespie method.  Only used in next_jump function, not in gettime. \n\n\n\n\n\n","category":"type"},{"location":"reaction_times/#CRMP.gettime","page":"Reaction times","title":"CRMP.gettime","text":"gettime(::constant_rate, ‚Ñì::reaction{T}, t::Real, x::Union{T, Array{T,1}}) where {T<:Real}\n\nReturns an Exp(‚Ñì.Œª(t,x))-random variable, provided ‚Ñì.Œª(t,x)>0. Else returns 1e10\n\n\n\n\n\ngettime(::decreasing_rate, ‚Ñì::reaction, t, x::Union{T, Array{T,1}}) where {T<:Real}\n\nReturns the reaction time of reaction ‚Ñì if ‚Ñì.Œª is decreasing in time. Uses a thinning algorithm with upper bound ‚Ñì.Œª(t,x). Returns 1e10 when ‚Ñì.Œª(t,x)=0. \n\n\n\n\n\ngettime(::increasing_rate, ‚Ñì::reaction{T}, t, x::Union{T, Array{T,1}}, setŒ¥::Function) where {T<:Real}\n\nReturns the reaction time of reaction ‚Ñì if ‚Ñì.Œª is increasing in time. Uses a thinning algorithm on compact intervals [t, t+Œ¥] where Œ¥ is obtained from setŒ¥ and time by Œ¥ is moved if the reaction time is not below Œ¥.\n\n\n\n\n\n","category":"function"},{"location":"reaction_times/#CRMP.setŒ¥","page":"Reaction times","title":"CRMP.setŒ¥","text":"setŒ¥(Œ∑::Real, diff::Float64, obs::observation{T}) where {T}\n\nreturns the function (‚Ñì t x)  T - t - 1( 2*log(Œ∑)diff + 1(T-t) ) for the thinning algorithm.\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#Likelihood","page":"Likelihood","title":"Likelihood","text":"","category":"section"},{"location":"likelihood/","page":"Likelihood","title":"Likelihood","text":"Functions for likelihood computation","category":"page"},{"location":"likelihood/","page":"Likelihood","title":"Likelihood","text":"CurrentModule = CRMP","category":"page"},{"location":"likelihood/","page":"Likelihood","title":"Likelihood","text":"loglikelihood\nloglikelihood_general_1obs\nlikelihood_general_1obs\niscorrect_1obs","category":"page"},{"location":"likelihood/#CRMP.loglikelihood","page":"Likelihood","title":"CRMP.loglikelihood","text":"loglikelihood(tt, xx, GP::Guided_Process, info)\n\nSpecifically for a guiding term exp(-0.5 x' H(t)x + F(t)'x) \n\n\n\n\n\n","category":"function"},{"location":"likelihood/#CRMP.loglikelihood_general_1obs","page":"Likelihood","title":"CRMP.loglikelihood_general_1obs","text":"loglikelihood_general_1obs(tt,xx, GP::T, info) where {T<:Guided_Process}\n\nGeneral log-likelihood computation, only dependent on guiding term, main method used\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#CRMP.likelihood_general_1obs","page":"Likelihood","title":"CRMP.likelihood_general_1obs","text":"likelihood_general_1obs(tt,xx, GP::T, info) where {T<:Guided_Process}\n\nGeneral likelihood computation, only dependent on guiding term, main method used\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#CRMP.iscorrect_1obs","page":"Likelihood","title":"CRMP.iscorrect_1obs","text":"iscorrect_1obs(GP::T, tt, xx) where {T<:Guided_Process}\n\nChecks whether LX(T) = v, returns a boolean. \n\n\n\n\n\n","category":"function"},{"location":"conditional_process/#Conditional-process","page":"Conditional process","title":"Conditional process","text":"","category":"section"},{"location":"conditional_process/","page":"Conditional process","title":"Conditional process","text":"Functions used in the simulation of guided processes","category":"page"},{"location":"conditional_process/","page":"Conditional process","title":"Conditional process","text":"CurrentModule = CRMP","category":"page"},{"location":"conditional_process/","page":"Conditional process","title":"Conditional process","text":"partial_observation\npartial_observation_poisson\ndiffusion_guiding_term\npoisson_guiding_term\nfilter_backward\nlog_guiding_term\nlog_guiding_term_poisson_only\nguiding_term\ncondition_reaction\ncondition_process","category":"page"},{"location":"conditional_process/#CRMP.partial_observation","page":"Conditional process","title":"CRMP.partial_observation","text":"partial_observation{T::Union{Real, AbstractArray{Real, 1}}}\n\nA partial observation vN(LX(t) œµ*LtildeaL) at time t with an m times d-matrix L and m  times m matrix C. Use\n\njulia> obs = partial_observation(1.0, [2, 5], [1 0 0 ; 0 1 0], 0.05)\njulia> gett(obs) # returns 1.0\njulia> getv(obs) # returns [2, 5]\njulia> getL(obs) # returns [1 0 0 ; 0 1 0]\njulia> getœµ(obs) # returns 0.05\njulia> getm(obs) # returns 2\njulia> getd(obs) # returns 3\n\n\n\n\n\n","category":"type"},{"location":"conditional_process/#CRMP.partial_observation_poisson","page":"Conditional process","title":"CRMP.partial_observation_poisson","text":"partial_observation_poisson{T::Union{Real, AbstractArray{Real, 1}}}\n\nA partial observation for a process with a monotone component  Assume an observation v = LX(t) with Lof the form[L‚ÇÅ 0 ; 0 L‚ÇÇ].L‚ÇÇ` for the monotone component,  Use:\n\njulia> obs = partial_observation_poisson(1.0, [2, 5], [ [1 0], [1] ],  0.05)\njulia> gett(obs) # returns 1.0\njulia> getv(obs) # returns [2, 5]\njulia> getL(obs) # returns [1 0 0 ; 0 0 1]\njulia> getL‚ÇÅ(obs)# returns [1 0] \njulia> getL‚ÇÇ(obs)# returns [1]\njulia> getœµ(obs) # returns 0.05\njulia> getm(obs) # returns 2\njulia> getd(obs) # returns 3\n\n\n\n\n\n\n","category":"type"},{"location":"conditional_process/#CRMP.diffusion_guiding_term","page":"Conditional process","title":"CRMP.diffusion_guiding_term","text":"diffusion_guiding_term{T}\n\nGuided process through array of partial observations obs, with an array d times d-matrices stored in  a and an original ChemicalReactionProcess P. \n\n# Guided GTT process for one partial observation at time 1.0 using a=I\njulia> partial_obs = [partial_observation(1.0, [2, 5], [1 0 0 ; 0 1 0], 0.05)]\njulia> GP = diffusion_guiding_term( partial_obs , [ [1 0 0 ; 0 1 0 ; 0 0 1] ] , GTT(Œ∫‚ÇÅ,Œ∫‚ÇÇ,d‚Çö,d‚Çò) )\n\n\n\n\n\n","category":"type"},{"location":"conditional_process/#CRMP.poisson_guiding_term","page":"Conditional process","title":"CRMP.poisson_guiding_term","text":"poisson_guiding_term{T}\n\nGuided process through array of partial observations obs, with an array d times d-matrices stored in  a, an integer Y that represents the amount of poisson terms and an original ChemicalReactionProcess P. \n\n# Guided GTT process for one partial observation at time 1.0 using a=I\njulia> partial_obs = [partial_observation(1.0, [2, 5], [1 0 0 ; 0 1 0], 0.05)]\njulia> GP = Guided_Process( partial_obs , [ [1 0 0 ; 0 1 0 ; 0 0 1] ] , 0, GTT(Œ∫‚ÇÅ,Œ∫‚ÇÇ,d‚Çö,d‚Çò) )\n\n\n\n\n\n","category":"type"},{"location":"conditional_process/#CRMP.filter_backward","page":"Conditional process","title":"CRMP.filter_backward","text":"filter_backward(GP::Guided_Process)\n\nReturns the quadruple (H,F, LaL‚Åª¬π, LC‚Åª¬π). All are arrays of size n that containns  H(t‚Çñ), F(t‚Çñ), (L‚Çñ a‚Çñ L‚Çñ)¬π and L( œµ L‚Çñ a‚Çñ L‚Çñ)¬π  k=1dotsn. Note, we return H(t‚Çñ) and F(t‚Çñ)\n\n\n\n\n\n","category":"function"},{"location":"conditional_process/#CRMP.log_guiding_term","page":"Conditional process","title":"CRMP.log_guiding_term","text":"log_guiding_term(info, GP::diffusion_guiding_term)\n\nReturns a function (‚Ñì t x) mapsto log h(tx+Œæ_‚Ñì) - log h(tx).  info should be the quadruple (H, F, LaL‚Åª¬π , LC‚Åª¬π) that results from filter_backward. \n\n\n\n\n\n","category":"function"},{"location":"conditional_process/#CRMP.log_guiding_term_poisson_only","page":"Conditional process","title":"CRMP.log_guiding_term_poisson_only","text":"log_guiding_term_poisson_only(GPP::poisson_guiding_term)\n\nReturns the log-guiding term as a function of (‚Ñì,t,x) for only poisson components\n\n\n\n\n\n","category":"function"},{"location":"conditional_process/#CRMP.guiding_term","page":"Conditional process","title":"CRMP.guiding_term","text":"guiding_term(info, GP::T) where {T<:Guided_Process}\n\nexp of the log guiding terms\n\n\n\n\n\n","category":"function"},{"location":"conditional_process/#CRMP.condition_reaction","page":"Conditional process","title":"CRMP.condition_reaction","text":"condition_reaction(‚Ñì::reaction{S}, xT::Union{S, Array{S,1}}, T::Real, guiding_term::Function) where {S<:Real}\n\nInput is a reaction ‚Ñì, a desired endpoint xT, end time T and a guiding term that is a function of (‚Ñì, t, x) and returns Œª(t x+‚ÑìŒæ)Œª(tx). Returns a reaction with the same difference vector Œæ, but with the conditioned rate specified in the paper.\n\n\n\n\n\n","category":"function"},{"location":"conditional_process/#CRMP.condition_process","page":"Conditional process","title":"CRMP.condition_process","text":"condition_process(P::ChemicalReactionProcess{S}, guiding_term::Function) where {S<:Real}\n\nReturns a new ChemicalReactionProcess{S} where all reaction in the network are conditioned using condition_reaction.\n\n\n\n\n\n","category":"function"},{"location":"forward_simulation/#Forward-simulation","page":"Forward simulation","title":"Forward simulation","text":"","category":"section"},{"location":"forward_simulation/","page":"Forward simulation","title":"Forward simulation","text":"Forward simulation of chemical reaction processes in various settings","category":"page"},{"location":"forward_simulation/","page":"Forward simulation","title":"Forward simulation","text":"CurrentModule = CRMP","category":"page"},{"location":"forward_simulation/","page":"Forward simulation","title":"Forward simulation","text":"next_jump\nsimulate_forward\nsimulate_forward_monotone","category":"page"},{"location":"forward_simulation/#CRMP.next_jump","page":"Forward simulation","title":"CRMP.next_jump","text":"next_jump(::constant_rate, t::Real, x::Union{T, Array{T,1}}, P::ChemicalReactionProcess{T}) where {T<:Real}\n\nIf the process is of constant (in time) rate, simulates exponential jump times for all reactions and returns the reaction with the shortest jump time along with the respective time.\n\n\n\n\n\nnext_jump(::Gillespie, t::Real, x::Union{T, Array{T,1}}, P::ChemicalReactionProcess{T}) where {T<:Real}\n\nIf the process is of constant (in time) rate, uses Gillespie's algorithm.\n\n\n\n\n\n","category":"function"},{"location":"forward_simulation/#CRMP.simulate_forward","page":"Forward simulation","title":"CRMP.simulate_forward","text":"simulate_forward(::constant_rate, x‚ÇÄ::Union{T1, Array{T1,1}}, T::T2, P::ChemicalReactionProcess{T1}) where {T1<:Real, T2<:Real}\n\nForward simulation starting from x‚ÇÄ, untime time T of the process specified in P when jump rates are constant (in time).\n\n\n\n\n\nsimulate_forward(::Gillespie, x‚ÇÄ::Union{T1, Array{T1,1}}, T::T2, P::ChemicalReactionProcess{T1}) where {T1<:Real, T2<:Real}\n\nForward simulation starting from x‚ÇÄ, untime time T of the process specified in P when jump rates are constant (in time).\n\n\n\n\n\nsimulate_forward(x‚ÇÄ,GP::Guided_Process, info)\n\nUpper bounds too large, does not work very well.\n\n\n\n\n\n","category":"function"},{"location":"forward_simulation/#CRMP.simulate_forward_monotone","page":"Forward simulation","title":"CRMP.simulate_forward_monotone","text":"simulate_forward_monotone(x‚ÇÄ, GP::diffusion_guiding_term{T}, info) where {T}\n\nCurrently the main simulation method for diffusion guiding terms. uitinizes the Œ¥\n\n\n\n\n\nsimulate_forward_monotone(x‚ÇÄ, GP::poisson_guiding_term{T}, info) where {T}\n\nCurrently the main simulation method for diffusion guiding terms. uitinizes the Œ¥ Assumes the last components are the monotone components.\n\n\n\n\n\n","category":"function"},{"location":"networks/#networks","page":"Networks","title":"Networks","text":"","category":"section"},{"location":"networks/","page":"Networks","title":"Networks","text":"Various function for setting up chemical reaction networks and several well-known networks","category":"page"},{"location":"networks/","page":"Networks","title":"Networks","text":"CurrentModule = CRMP","category":"page"},{"location":"networks/","page":"Networks","title":"Networks","text":"reaction\nChemicalReactionNetwork\nChemicalReactionProcess\nnr_species\nnr_reactions\nPoissonProcess_constantrate\nPureDeathProcess_constantrate\nBirthDeathProcess\nGTT\nSchlogl\nAR\nviral_infection\nenzyme_kinetics\nlotka_volterra","category":"page"},{"location":"networks/#CRMP.reaction","page":"Networks","title":"CRMP.reaction","text":"reaction{T<:Real}\n\nA reaction, specified through a rate function Œª of time and space and a difference vector Œæ. For example, a unit rate poisson has one reaction, specified as\n\njulia> plus1 = reaction((t,x) -> x, 1)\n\n\n\n\n\n","category":"type"},{"location":"networks/#CRMP.ChemicalReactionNetwork","page":"Networks","title":"CRMP.ChemicalReactionNetwork","text":"ChemicalReactionNetwork{T<:Real}\n\nA chemical reaction network is set-up as a tuple of a vector of species ùíÆ with Strings as input and a vector of reaction{T}s. I still need some way to distinct between process and network\n\n\n\n\n\n","category":"type"},{"location":"networks/#CRMP.ChemicalReactionProcess","page":"Networks","title":"CRMP.ChemicalReactionProcess","text":"ChemicalReactionProcess{T<:Real}\n\nA chemical reaction process is set-up as a tuple of a vector of species ùíÆ with Strings as input and a vector of reaction{T}s. I still need some way to distinct between process and network For example, a poisson process is set-up as follows\n\njulia> plus1 = reaction((t,x) -> x, 1)\njulia> PoissonProcecss = ChemicalReactionProcess([\"Counts\"], [plus1])\n\nAlternatively, if there is just one reaction, or species, one could omit the Array.\n\n\n\n\n\n","category":"type"},{"location":"networks/#CRMP.nr_species","page":"Networks","title":"CRMP.nr_species","text":"nr_species(P::ChemicalReactionProcess)\n\nReturns how much species a ChemicalReactionProcess contains\n\n\n\n\n\n","category":"function"},{"location":"networks/#CRMP.nr_reactions","page":"Networks","title":"CRMP.nr_reactions","text":"nr_reactions(P::ChemicalReactionProcess)\n\nReturns how much reactions a ChemicalReactionProcess contains\n\n\n\n\n\n","category":"function"},{"location":"networks/#CRMP.PoissonProcess_constantrate","page":"Networks","title":"CRMP.PoissonProcess_constantrate","text":"PoissonProcess_constantrate(rate::Real)\n\nReturns a ChemicalReactionProcess for the Poisson process with constant rate rate.\n\n\n\n\n\n","category":"function"},{"location":"networks/#CRMP.BirthDeathProcess","page":"Networks","title":"CRMP.BirthDeathProcess","text":"BirthDeathProcess(birth_rate::Real , death_rate::Real)\n\nReturns a ChemicalReactionProcess for the birth-death process with parameters birth_rate and death_rate\n\n\n\n\n\n","category":"function"},{"location":"networks/#CRMP.GTT","page":"Networks","title":"CRMP.GTT","text":"GTT(Œ∫‚ÇÅ::T ,Œ∫‚ÇÇ::T, d‚Çò::T, d‚Çö::T) where {T<:Real}\n\nReturns a ChemicalReactionProcess for Gene transcriptiona and translation as described in section 2.1.something of Anderson & Kurtz with\n\ntranscription rate Œ∫‚ÇÅ\ntranslation rate Œ∫‚ÇÇ\ndegradation rate of mRNA d‚Çò\ndegradation rate of protein d‚Çö\n\n\n\n\n\nGTT(Œ∫‚ÇÅ::T ,Œ∫‚ÇÇ::T, Œ∫‚ÇÉ::T, d‚Çò::T, d‚Çö::T, dD::T) where {T<:Real}\n\nSimilar to GTT but with the inclusion of dimerization with dimerization rate Œ∫‚ÇÉ and degradation rate of dimer dD\n\n\n\n\n\n","category":"function"},{"location":"networks/#CRMP.Schlogl","page":"Networks","title":"CRMP.Schlogl","text":"Schlogl(Œ∫‚ÇÅ::T,Œ∫‚ÇÇ::T,Œ∫‚ÇÉ::T,Œ∫‚ÇÑ:T) where {T<:Real}\n\nSchlogl model (#X, #A,#B). \n\n\n\n\n\n","category":"function"},{"location":"networks/#CRMP.viral_infection","page":"Networks","title":"CRMP.viral_infection","text":"viral_infection(Œ∫‚ÇÅ::T, Œ∫‚ÇÇ::T, Œ∫‚ÇÉ::T, Œ∫‚ÇÑ::T, Œ∫‚ÇÖ::T, Œ∫‚ÇÜ::T) where {T<:Real}\n\nChemicalReactionProcess for viral infection, See e.g. section 2.1.2 of Anderson & Kurtz\n\n\n\n\n\n","category":"function"},{"location":"networks/#CRMP.enzyme_kinetics","page":"Networks","title":"CRMP.enzyme_kinetics","text":"enzyme_kinetics(Œ∫‚ÇÅ::T, Œ∫‚ÇÇ::T, Œ∫‚ÇÉ::T) where {T<:Real}\n\nSee e.g. section 2.1.3 of Anderson & Kurtz\n\n\n\n\n\n","category":"function"},{"location":"networks/#CRMP.lotka_volterra","page":"Networks","title":"CRMP.lotka_volterra","text":"lotka_volterra(Œ∫‚ÇÅ, Œ∫‚ÇÇ, Œ∫‚ÇÉ)\n\nwell known, pred -> ‚àÖ , prey -> 2prey and pred + prey = 2pred\n\n\n\n\n\n","category":"function"},{"location":"#Documentation-for-CRMP.jl","page":"Home","title":"Documentation for CRMP.jl","text":"","category":"section"},{"location":"#Summary","page":"Home","title":"Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Library with functions for forward simulation of continuous-time chemical reaction process and performing statistical inference on such process. Manual to be added later.","category":"page"},{"location":"#Walkthrough-for-Birth-death-process","page":"Home","title":"Walkthrough for Birth-death process","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The birth death-process consists of the simple species set ùíÆ = {\"Individuals\"} and the reactions birth and death with rates birth_rate and death_rate, respectively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using CRMP\njulia> birth = reaction( (t,x) -> x + 1 , birth_rate*x)\njulia> death = reaction( (t,x) -> x - 1 , death_rate*x)\njulia> P = ChemicalReactionProcess([\"Individuals\"], [birth, death])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Acces the set of species or the set of reactions through P.ùíÆ and P.‚Ñõ respectively. The birth-death process is also a buit-in function of this library accessed through","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> P = BirthDeathProcess(birth_rate, death_rate)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For other built-in reaction process, see networks.","category":"page"},{"location":"#Forward-simulation","page":"Home","title":"Forward simulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The rate functions are constant in time and thus we simulate forward given x‚ÇÄ and some final time T using","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> tt, xx = simulate_forward(constant_rate(), x‚ÇÄ, T, P)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can plot the components using ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> plotprocess(tt, xx, P)","category":"page"},{"location":"#Conditioned-process","page":"Home","title":"Conditioned process","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If we have a desired end-state (T,xT), we can employ various guiding terms to find a guided process. See Conditional processes for all of them. We demostrate the diffusion guiding term.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> L = 1.0\njulia> eps = 1e-5\njulia> obs = partial_observation(T, xT, L, eps)\njulia> a = 10.0\njulia> GP = diffusion_guiding_term(obs, a, P)\njulia> info = filter_backward(GP)\njulia> tto, xxo = simulate_forward_monotone(x‚ÇÄ, GP, info)","category":"page"},{"location":"#Likelihood-computation","page":"Home","title":"Likelihood computation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For likelihood computation with 1 observation, the preferred method is the function loglikelihood_general_1obs. For multiple observations, LNA methods are not implemented yet. For poisson and diffusion guiding terms, use loglikelihood(tto,xxo,GP,info)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Continuing the example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> loglikelihood_general_1obs(tto, xxo, GP, info)","category":"page"},{"location":"#Extension-to-multiple-observations","page":"Home","title":"Extension to multiple observations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For multiple observations, use the methods prescribed earlier, but then with an array of partial_observations and an array of a.","category":"page"},{"location":"LNA/#LNA","page":"LNA","title":"LNA","text":"","category":"section"},{"location":"LNA/","page":"LNA","title":"LNA","text":"Implementation of the LNA method","category":"page"},{"location":"LNA/","page":"LNA","title":"LNA","text":"CurrentModule = CRMP","category":"page"},{"location":"LNA/","page":"LNA","title":"LNA","text":"LNA\nLNAR\nLNAR_death\nLNA_nR\ndiff_death\npois_death","category":"page"},{"location":"LNA/#CRMP.LNA","page":"LNA","title":"CRMP.LNA","text":"LNA\n\ngeneral supertype for different LNA algorithms\n\n\n\n\n\n","category":"type"},{"location":"LNA/#CRMP.LNAR","page":"LNA","title":"CRMP.LNAR","text":"LNAR\n\nLNA method with restart, guided rates are determined through solving  a system of ODEs at each reaction time.  julia-repl julia> obs = partial_observation(1.0, [2, 5], [1 0 0 ; 0 1 0], 0.05) julia> LNAR(obs, GTT(1.0, 1.0, 1.0, 1.0))`\n\n\n\n\n\n","category":"type"},{"location":"LNA/#CRMP.LNAR_death","page":"LNA","title":"CRMP.LNAR_death","text":"LNAR_death\n\nLNA method with restart, closed form solution to the ODEs  specifically implemented for the death process. Works the same as LNAR\n\n\n\n\n\n","category":"type"},{"location":"LNA/#CRMP.LNA_nR","page":"LNA","title":"CRMP.LNA_nR","text":"LNA_nR\n\nLNA method without restart. requires fillin œàt, Gt, and zt on a grid before use ```julia-repl julia> obs = partialobservation(1.0, [2, 5], [1 0 0 ; 0 1 0], 0.05) julia> timegrid = 0.0:0.001:1.0 julia> GP = LNAnR(obs, timegrid, GTT(1.0, 1.0, 1.0, 1.0)) julia> x‚ÇÄ = [1, 15, 20] julia> fill_grid!(GP, x‚ÇÄ)\n\n\n\n\n\n","category":"type"},{"location":"LNA/#CRMP.diff_death","page":"LNA","title":"CRMP.diff_death","text":"diff_death\n\nspecific guiding term for the death process with a diffusion guiding term\n\njulia> obs = partial_observation(1.0, 35, 1.0, 0.05)\njulia> a = 15.0\njulia> GP = diff_death(obs, a, PureDeathProcess_constantrate(0.5))\n\n\n\n\n\n","category":"type"},{"location":"LNA/#CRMP.pois_death","page":"LNA","title":"CRMP.pois_death","text":"pois_death\n\nspecific guiding term for the death process with a poisson guiding term\n\njulia> obs = julia> obs = partial_observation(1.0, 35, [nothing, 1.0], 0.05)\njulia> GP = pois_death(obs, PureDeathProcess_constantrate(0.5))\n\n\n\n\n\n","category":"type"}]
}
